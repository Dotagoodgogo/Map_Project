//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"

// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 6;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "BrickWallTexture.bmp",
    "KalachakraSera.bmp",
    "RoughWood.bmp",
    "marble.bmp",
    "snow.bmp",
    "cswall.bmp"
};

// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.75);   


// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 76;
const int iFloor = 0;
const int iCircularSurf = 1;
const int iWall = 2;            // RESERVED FOR USE BY 155A PROJECT
const int iWall2 = 3;  
const int iWall3 = 4;
const int iWall4 = 5;

const int iMiddle = 6;
const int iMiddle2 = 7;
const int iMiddle3 = 8;
const int iMiddle4 = 9;
const int icover = 10;

const int iMiddle5 = 11;
const int iMiddle6 = 12;
const int iMiddle7 = 13;
const int iMiddle8 = 14;
const int icover2 = 15;

const int iMiddle9 = 16;
const int iMiddle10 = 17;
const int iMiddle11 = 18;
const int iMiddle12 = 19;
const int icover3 = 20;

const int iMiddle13 = 21;
const int iMiddle14 = 22;
const int iMiddle15 = 23;
const int iMiddle16 = 24;
const int icover4 = 25;

const int iSideWall1 = 26;
const int iSideWall2 = 27;
const int iSideWall3 = 28;
const int iSideCover1 = 29;

const int iSideWall4 = 30;
const int iSideWall5 = 31;
const int iSideWall6 = 32;
const int iSideCover2 = 33;

const int iSideWall7 = 34;
const int iSideWall8 = 35;
const int iSideWall9 = 36;
const int iSideCover3 = 37;

const int iSideWall10 = 38;
const int iSideWall11 = 39;
const int iSideWall12 = 40;
const int iSideCover4 = 41;

const int iSideWall13 = 42;
const int iSideWall14 = 43;
const int iSideWall15 = 44;
const int iSideCover5 = 45;

const int iSideWall16 = 46;
const int iSideWall17 = 47;
const int iSideWall18 = 48;
const int iSideCover6 = 49;

const int iCorner1 = 50;
const int iCorner2 = 51;
const int iCorner3 = 52;
const int iCorner4 = 53;

const int im1 = 54;
const int im2 = 55;
const int im3 = 56;
const int im4 = 57;
const int im5 = 58;
const int im6 = 59;

const int try1 = 60;
const int try2 = 61;
const int try3 = 62;
const int try4 = 63;

const int try5 = 64;
const int try6 = 65;
const int try7 = 66;
const int try8 = 67;

const int try9 = 68;
const int try10 = 69;
const int try11 = 70;
const int try12 = 71;

const int try13 = 72;
const int try14 = 73;
const int try15 = 74;
const int try16 = 75;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -7.5f, 0.0f, -7.5f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         7.5f, 0.0f, -7.5f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         7.5f, 0.0f,  7.5f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -7.5f, 0.0f,  7.5f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);

   
    float wallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -7.5f, 3.0f,-7.5f,     0.0f, 0.0f, 1.0f,          0.0f, 1.0f,        // upper left
        -7.5f, 0.0f, -7.5f,      0.0f, 0.0f, 1.0f,         0.0f, 0.0f,         // lower left
        7.5f, 3.0f, -7.5f,     0.0f, 0.0f, 1.0f,          1.0f, 1.0f,       // upper right
        7.5f, 0.0f,  -7.5f,      0.0f, 0.0f, 1.0f,         1.0f, 0.0f,         // lower right
    };

    unsigned int wallElts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts), wallElts, GL_STATIC_DRAW);

    float wall2Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -7.5f, 3.0f,-7.5f,     1.0f, 0.0f, 0.0f,          0.0f, 1.0f,        // upper left
        -7.5f, 0.0f, -7.5f,    1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left
        -7.5f, 3.0f, 7.5f,     1.0f, 0.0f, 0.0f,          1.0f, 1.0f,       // upper right
        -7.5f, 0.0f,  7.5f,    1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int wall2Elts[] = { 2, 3, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall2]);
    glBindVertexArray(myVAO[iWall2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wall2Verts), wall2Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wall2Elts), wall2Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float wall3Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -7.5f, 3.0f,7.5f,     0.0f, 0.0f, -1.0f,          0.0f, 1.0f,        // upper left
        -7.5f, 0.0f, 7.5f,    0.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left
        7.5f, 3.0f, 7.5f,     0.0f, 0.0f, -1.0f,          1.0f, 1.0f,       // upper right
        7.5f, 0.0f,  7.5f,    0.0f, 0.0f, -1.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int wall3Elts[] = { 2, 3, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall3]);
    glBindVertexArray(myVAO[iWall3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wall3Verts), wall3Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wall3Elts), wall3Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float wall4Verts[] = {
        // Position              // Normal                  // Texture coordinates
        7.5f, 3.0f, 7.5f,     -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,        // upper left
        7.5f, 0.0f, 7.5f,    -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left
        7.5f, 3.0f, -7.5f,     -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,       // upper right
        7.5f, 0.0f, -7.5f,    -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int wall4Elts[] = { 2, 3, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall4]);
    glBindVertexArray(myVAO[iWall4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wall4Verts), wall4Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wall4Elts), wall4Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middleVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 3.0f, -4.5f,     -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,        // upper left
        -4.5f, 0.0f, -4.5f,     -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 3.0f, -1.0f,    -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,       // upper right
        -4.5f, 0.0f, -1.0f,    -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int middleElts[] = { 0, 1, 2, 3};
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle]);
    glBindVertexArray(myVAO[iMiddle]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middleVerts), middleVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middleElts), middleElts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try1Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.0f, 3.0f, -0.75f,     -1.0f, 0.0f, 2.0f,          0.0f, 1.0f,        // upper left
        -4.0f, 0.0f, -0.75f,     -1.0f, 0.0f, 2.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 3.0f, -1.0f,    -1.0f, 0.0f, 2.0f,          1.0f, 1.0f,       // upper right
        -4.5f, 0.0f, -1.0f,    -1.0f, 0.0f, 2.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int try1Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try1]);
    glBindVertexArray(myVAO[try1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try1Verts), try1Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try1Elts), try1Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle2Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.0f, 3.0f, -0.75f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -4.0f, 0.0f, -0.75f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -1.25f, 3.0f, -0.75f,     0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -1.25f, 0.0f, -0.75f,     0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle2Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle2]);
    glBindVertexArray(myVAO[iMiddle2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle2Verts), middle2Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle2Elts), middle2Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try2Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.25f, 3.0f, -0.75f,     1.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -1.25, 0.0f, -0.75f,      1.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -0.75f, 3.0f, -1.25f,     1.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -0.75f, 0.0f, -1.25f,     1.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try2Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try2]);
    glBindVertexArray(myVAO[try2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try2Verts), try2Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try2Elts), try2Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float middle3Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -0.75f, 3.0f, -1.25f,      1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -0.75f, 0.0f, -1.25f,      1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -0.75f, 3.0f, -4.0f,     1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -0.75f, 0.0f, -4.0f,     1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle3Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle3]);
    glBindVertexArray(myVAO[iMiddle3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle3Verts), middle3Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle3Elts), middle3Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try3Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -0.75f, 3.0f, -4.0f,      2.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -0.75f, 0.0f, -4.0f,      2.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        -1.0f, 3.0f, -4.5f,     2.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -1.0f, 0.0f, -4.5f,     2.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try3Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try3]);
    glBindVertexArray(myVAO[try3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try3Verts), try3Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try3Elts), try3Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float middle4Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 3.0f, -4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -1.0f, 0.0f, -4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 3.0f, -4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -4.5f, 0.0f, -4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle4Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle4]);
    glBindVertexArray(myVAO[iMiddle4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle4Verts), middle4Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle4Elts), middle4Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try4Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.25f, 3.0f, -0.75f,       0.0f, 1.0f, 0.0f,          0.86f,0.0f,
        -0.75f, 3.0f, -1.25f,       0.0f, 1.0f, 0.0f,          1.0f, 0.14f,         // upper left
        -0.75f, 3.0f, -4.0f,        0.0f, 1.0f, 0.0f,          1.0f, 0.86f,         // lower left
        -1.0f, 3.0f, -4.5f,        0.0f, 1.0f, 0.0f,          0.93f, 1.0f,        // upper right
        -4.5f, 3.0f, -4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 1.0f,        // lower right
        -4.5f, 3.0f, -1.0f,       0.0f, 1.0f, 0.0f,          0.0f, 0.07f,
        -4.0f, 3.0f, -0.75f,       0.0f, 1.0f, 0.0f,          0.14f, 0.0f,

    };

    unsigned int try4Elts[] = { 0, 1, 2, 3, 4, 5, 6};
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try4]);
    glBindVertexArray(myVAO[try4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try4Verts), try4Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try4Elts), try4Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle5Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f + 5.25f, 3.0f, -4.0f,     -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,        // upper left
        -4.5f + 5.25f, 0.0f, -4.0f,     -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -4.5f + 5.25f, 3.0f, -1.25f,    -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,       // upper right
        -4.5f + 5.25f, 0.0f, -1.25f,    -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int middle5Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle5]);
    glBindVertexArray(myVAO[iMiddle5]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle5Verts), middle5Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle5Elts), middle5Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try5Verts[] = {
        // Position              // Normal                  // Texture coordinates
        0.75f, 3.0f, -4.0f,     -2.0f, 0.0f, -1.0f,          0.0f, 1.0f,        // upper left
        0.75f, 0.0f, -4.0f,     -2.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        1.0f, 3.0f, -4.5f,    -2.0f, 0.0f, -1.0f,          1.0f, 1.0f,       // upper right
        1.0f, 0.0f, -4.5f,    -2.0f, 0.0f, -1.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int try5Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try5]);
    glBindVertexArray(myVAO[try5]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try5Verts), try5Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try5Elts), try5Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle6Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f + 5.75f, 3.0f, -0.75f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -4.5f + 5.75f, 0.0f, -0.75f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        4.0f, 3.0f, -0.75f,     0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        4.0f, 0.0f, -0.75f,     0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle6Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle6]);
    glBindVertexArray(myVAO[iMiddle6]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle6Verts), middle6Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle6Elts), middle6Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try6Verts[] = {
        // Position              // Normal                  // Texture coordinates
        0.75f, 3.0f, -1.25f,      -1.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        0.75f, 0.0f, -1.25f,      -1.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        1.25f, 3.0f, -0.75f,     -1.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        1.25f, 0.0f, -0.75f,     -1.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try6Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try6]);
    glBindVertexArray(myVAO[try6]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try6Verts), try6Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try6Elts), try6Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float middle7Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -0.75f + 5.25f, 3.0f, -1.0f,      1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -0.75f + 5.25f, 0.0f, -1.0f,      1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -0.75f + 5.25f, 3.0f, -4.5f,     1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -0.75f + 5.25f, 0.0f, -4.5f,     1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle7Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle7]);
    glBindVertexArray(myVAO[iMiddle7]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle7Verts), middle7Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle7]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle7Elts), middle7Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try7Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.0f, 3.0f, -0.75f,      1.0f, 0.0f, 2.0f,          0.0f, 1.0f,         // upper left
        4.0f, 0.0f, -0.75f,      1.0f, 0.0f, 2.0f,          0.0f, 0.0f,         // lower left

        4.5f, 3.0f, -1.0f,     1.0f, 0.0f, 2.0f,          1.0f, 1.0f,        // upper right
        4.5f, 0.0f, -1.0f,     1.0f, 0.0f, 2.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try7Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try7]);
    glBindVertexArray(myVAO[try7]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try7Verts), try7Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try7]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try7Elts), try7Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle8Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -0.75f + 5.25f, 3.0f, -4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -0.75f + 5.25f, 0.0f, -4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        -4.5f + 5.5f, 3.0f, -4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -4.5f + 5.5f, 0.0f, -4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle8Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle8]);
    glBindVertexArray(myVAO[iMiddle8]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle8Verts), middle8Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle8]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle8Elts), middle8Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float try8Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.0f, 3.0f, -0.75f,       0.0f, 1.0f, 0.0f,          0.86f,0.0f,
        4.5f, 3.0f, -1.0f,        0.0f, 1.0f, 0.0f,          1.0f, 0.14f,         // upper left
        4.5f, 3.0f, -4.5f,        0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // lower left
        1.0f, 3.0f, -4.5f,        0.0f, 1.0f, 0.0f,          0.14f, 1.0f,        // upper right
        0.75f, 3.0f, -4.0f,       0.0f, 1.0f, 0.0f,          0.0f, 0.86f,        // lower right
        0.75, 3.0f, -1.25f,       0.0f, 1.0f, 0.0f,          0.0f, 0.14f,
        1.25f, 3.0f, -0.75f,       0.0f, 1.0f, 0.0f,          0.14f, 0.0f,
    };

    unsigned int try8Elts[] = { 0, 1, 2, 3,4,5,6};
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try8]);
    glBindVertexArray(myVAO[try8]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try8Verts), try8Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try8]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try8Elts), try8Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle9Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 3.0f, 1.0f,     -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,        // upper left
        -4.5f, 0.0f, 1.0f,     -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 3.0f, -0.75f + 5.25f,    -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,       // upper right
        -4.5f, 0.0f, -0.75f + 5.25f,    -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int middle9Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle9]);
    glBindVertexArray(myVAO[iMiddle9]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle9Verts), middle9Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle9]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle9Elts), middle9Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try9Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.25f, 3.0f, 0.75f,         1.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -1.25f, 0.0f, 0.75f,        1.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        -0.75f, 3.0f, 1.25f,        1.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -0.75f, 0.0f, 1.25f,       1.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try9Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try9]);
    glBindVertexArray(myVAO[try9]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try9Verts), try9Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try9]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try9Elts), try9Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle10Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 3.0f, -0.75f + 5.25f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -4.5f, 0.0f, -0.75f + 5.25f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -1.0f, 3.0f, -0.75f + 5.25f,     0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -1.0f, 0.0f, -0.75f + 5.25f,     0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle10Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle10]);
    glBindVertexArray(myVAO[iMiddle10]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle10Verts), middle10Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle10]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle10Elts), middle10Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try10Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.0f, 3.0f, 0.75f,        -1.0f, 0.0f, -2.0f,          0.0f, 1.0f,         // upper left
        -4.0f, 0.0f, 0.75f,        -1.0f, 0.0f, -2.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 3.0f, 1.0f,        -1.0f, 0.0f, -2.0f,          1.0f, 1.0f,        // upper right
        -4.5f, 0.0f, 1.0f,        -1.0f, 0.0f, -2.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try10Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try10]);
    glBindVertexArray(myVAO[try10]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try10Verts), try10Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try10]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try10Elts), try10Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float middle11Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -0.75f, 3.0f, -1.25 + 5.25f,      1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -0.75f, 0.0f, -1.25f + 5.25f,      1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -0.75f, 3.0f, -4.5f + 5.75f,     1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -0.75f, 0.0f, -4.5f + 5.75f,     1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle11Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle11]);
    glBindVertexArray(myVAO[iMiddle11]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle11Verts), middle11Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle11]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle11Elts), middle11Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try11Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 3.0f, 4.5f,        2.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -1.0f, 0.0f, 4.5f,        2.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -0.75f, 3.0f, 4.0f,        2.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -0.75f, 0.0f, 4.0f,        2.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try11Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try11]);
    glBindVertexArray(myVAO[try11]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try11Verts), try11Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try11]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try11Elts), try11Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle12Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.25f, 3.0f, -4.5 + 5.25f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -1.25f, 0.0f, -4.5f + 5.25f,       0.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        -4.0f, 3.0f, -4.5f + 5.25f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -4.0f, 0.0f, -4.5f + 5.25f,        0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle12Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle12]);
    glBindVertexArray(myVAO[iMiddle12]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle12Verts), middle12Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle12]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle12Elts), middle12Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float cover3Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 3.0f, -4.5f + 5.25f,         0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -4.5f, 3.0f, -0.75f + 5.25f,        0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -0.75f, 3.0f, -4.5f + 5.25f,        0.0f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -0.75f, 3.0f, -0.75f +5.25f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int cover3Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[icover3]);
    glBindVertexArray(myVAO[icover3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cover3Verts), cover3Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[icover3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(cover3Elts), cover3Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try12Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -1.0f, 3.0f, 4.5f,        0.0f, 1.0f, 0.0f,          0.93f, 0.0f,         // upper left
        -0.75f, 3.0f, 4.0f,        0.0f, 1.0f, 0.0f,          1.0f, 0.14f,         // lower left

        -0.75f, 3.0f, 1.25f,        0.0f, 1.0f, 0.0f,          1.0f, 0.86f,        // upper right
        -1.25f, 3.0f, 0.75f,        0.0f, 1.0f, 0.0f,          0.86f, 1.0f,        // lower right
        -4.0f, 3.0f, 0.75f,        0.0f, 1.0f, 0.0f,          0.14f, 1.0f,
        -4.5f, 3.0f, 1.0f,        0.0f, 1.0f, 0.0f,          0.0f, 0.93f,
        -4.5f, 3.0f, 4.5f,        0.0f, 1.0f, 0.0f,          0.0f, 0.0f,
    };

    unsigned int try12Elts[] = { 0, 1, 2, 3,4,5,6};
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try12]);
    glBindVertexArray(myVAO[try12]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try12Verts), try12Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try12]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try12Elts), try12Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    


    float middle13Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f + 5.25f, 3.0f, 1.25f,     -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,        // upper left
        -4.5f + 5.25f, 0.0f, 1.25f,     -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -4.5f + 5.25f, 3.0f, 4.0f,    -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,       // upper right
        -4.5f + 5.25f, 0.0f, 4.0f,    -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,         // lower right
    };

    unsigned int middle13Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle13]);
    glBindVertexArray(myVAO[iMiddle13]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle13Verts), middle13Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle13]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle13Elts), middle13Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try13Verts[] = {
        // Position              // Normal                  // Texture coordinates
        0.75f, 3.0f, 1.25f,        -1.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        0.75f, 0.0f, 1.25f,        -1.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        1.25f, 3.0f, 0.75f,        -1.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        1.25f, 0.0f, 0.75f,        -1.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try13Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try13]);
    glBindVertexArray(myVAO[try13]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try13Verts), try13Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try13]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try13Elts), try13Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle14Verts[] = {
        // Position              // Normal                  // Texture coordinates
        1.0f, 3.0f, -0.75f + 5.25f,      0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        1.0f, 0.0f, -0.75f + 5.25f,      0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -0.75f + 5.25f, 3.0f, -0.75f + 5.25f,     0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -0.75f + 5.25f, 0.0f, -0.75f + 5.25f,     0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle14Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle14]);
    glBindVertexArray(myVAO[iMiddle14]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle14Verts), middle14Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle14]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle14Elts), middle14Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try14Verts[] = {
        // Position              // Normal                  // Texture coordinates
        0.75f, 3.0f, 4.0f,        -2.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        0.75f, 0.0f, 4.0f,        -2.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        1.00f, 3.0f, 4.5f,        -2.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        1.00f, 0.0f, 4.5f,        -2.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try14Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try14]);
    glBindVertexArray(myVAO[try14]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try14Verts), try14Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try14]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try14Elts), try14Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float middle15Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -0.75f + 5.25f, 3.0f, -0.75f + 5.25f,      1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -0.75f + 5.25f, 0.0f, -0.75f + 5.25f,      1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -0.75f + 5.25f, 3.0f, 1.0f,     1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -0.75f + 5.25f, 0.0f, 1.0f,     1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle15Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle15]);
    glBindVertexArray(myVAO[iMiddle15]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle15Verts), middle15Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle15]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle15Elts), middle15Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try15Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 3.0f, 1.0f,        1.0f, 0.0f, -2.0f,          0.0f, 1.0f,         // upper left
        4.5f, 0.0f, 1.0f,        1.0f, 0.0f, -2.0f,          0.0f, 0.0f,         // lower left

        4.0f, 3.0f, 0.75f,        1.0f, 0.0f, -2.0f,          1.0f, 1.0f,        // upper right
        4.0f, 0.0f, 0.75f,        1.0f, 0.0f, -2.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int try15Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try15]);
    glBindVertexArray(myVAO[try15]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try15Verts), try15Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try15]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try15Elts), try15Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float middle16Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.0f, 3.0f, -4.5 + 5.25f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        4.0f, 0.0f, -4.5f + 5.25f,       0.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        1.25f, 3.0f, -4.5f + 5.25f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        1.25f, 0.0f, -4.5f + 5.25f,        0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int middle16Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iMiddle16]);
    glBindVertexArray(myVAO[iMiddle16]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(middle16Verts), middle16Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iMiddle16]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(middle16Elts), middle16Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float cover4Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f + 5.25f, 3.0f, -4.5f + 5.25f,         0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -4.5f + 5.25f, 3.0f, -0.75f + 5.25f,        0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -0.75f + 5.25f, 3.0f, -4.5f + 5.25f,        0.0f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -0.75f + 5.25f, 3.0f, -0.75f + 5.25f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int cover4Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[icover4]);
    glBindVertexArray(myVAO[icover4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cover4Verts), cover4Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[icover4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(cover4Elts), cover4Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float try16Verts[] = {
        // Position              // Normal                  // Texture coordinates
        1.0f, 3.0f, 4.5f,         0.0f, 1.0f, 0.0f,          0.07f, 0.0f,         // upper left
        4.5f, 3.0f, 4.5f,        0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // lower left

        4.5f, 3.0f, 1.0f,        0.0f, 1.0f, 0.0f,          1.0f, 0.93f,        // upper right
        4.0f, 3.0f, 0.75f,       0.0f, 1.0f, 0.0f,          0.86f, 1.0f, 
        1.25f, 3.0f, 0.75f,       0.0f, 1.0f, 0.0f,          0.14f, 1.0f,
        0.75f, 3.0f, 1.25f,       0.0f, 1.0f, 0.0f,          0.0f, 0.86f,
        0.75f, 3.0f, 4.0f,       0.0f, 1.0f, 0.0f,          0.0f, 0.14f,
    };

    unsigned int try16Elts[] = { 0, 1, 2, 3,4,5,6 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[try16]);
    glBindVertexArray(myVAO[try16]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(try16Verts), try16Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[try16]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(try16Elts), try16Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float sidewall1Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 1.0f, -4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -4.5f, 0.0f, -4.5f,       0.0f, 0.0f,-1.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 1.0f, -4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, -4.5f,       0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall1Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall1]);
    glBindVertexArray(myVAO[iSideWall1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall1Verts), sidewall1Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall1Elts), sidewall1Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall2Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 1.0f, -4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -4.5f, 0.0f, -4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 1.0f, -4.0f,        0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, -4.0f,       0.0f, 0.0f,  1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall2Elts[] = { 2, 3, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall2]);
    glBindVertexArray(myVAO[iSideWall2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall2Verts), sidewall2Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall2Elts), sidewall2Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall3Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -6.0f, 1.0f, -4.5f,       -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 0.0f, -4.5f,       -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 1.0f, -4.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, -4.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall3Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall3]);
    glBindVertexArray(myVAO[iSideWall3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall3Verts), sidewall3Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall3Elts), sidewall3Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float isideCover1Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 1.0f, -4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 1.0f, -4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 1.0f, -4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 1.0f, -4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int isideCover1Elts[] = { 2, 0, 3, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideCover1]);
    glBindVertexArray(myVAO[iSideCover1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(isideCover1Verts), isideCover1Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideCover1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(isideCover1Elts), isideCover1Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();





    float sidewall4Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 1.0f, 4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -4.5f, 0.0f, 4.5f,       0.0f, 0.0f,-1.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 1.0f, 4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, 4.5f,       0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall4Elts[] = { 2, 3, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall4]);
    glBindVertexArray(myVAO[iSideWall4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall4Verts), sidewall4Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall4Elts), sidewall4Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall5Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 1.0f, 4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -4.5f, 0.0f, 4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 1.0f, 4.0f,        0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, 4.0f,       0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall5Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall5]);
    glBindVertexArray(myVAO[iSideWall5]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall5Verts), sidewall5Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall5Elts), sidewall5Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float sidewall6Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -6.0f, 1.0f, 4.0f,       -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 0.0f, 4.0f,       -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 1.0f, 4.5f,        -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, 4.5f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall6Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall6]);
    glBindVertexArray(myVAO[iSideWall6]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall6Verts), sidewall6Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall6Elts), sidewall6Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float isideCover2Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -4.5f, 1.0f, 4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 1.0f, 4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -4.5f, 1.0f, 4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 1.0f, 4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int isideCover2Elts[] = { 3,1,2,0 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideCover2]);
    glBindVertexArray(myVAO[iSideCover2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(isideCover2Verts), isideCover2Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideCover2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(isideCover2Elts), isideCover2Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall7Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -6.0f, 0.8f, -0.25f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 0.0f, -0.25f,       0.0f, 0.0f,-1.0f,          0.0f, 0.0f,         // lower left

        -7.5f, 1.0f, -0.25f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -7.5f, 0.0f, -0.25f,       0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall7Elts[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall7]);
    glBindVertexArray(myVAO[iSideWall7]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall7Verts), sidewall7Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall7]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall7Elts), sidewall7Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall8Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -6.0f, 0.8f, 0.25f,       0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 0.0f, 0.25f,       0.0f, 0.0f,1.0f,          0.0f, 0.0f,         // lower left

        -7.5f, 1.0f, 0.25f,        0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -7.5f, 0.0f, 0.25f,       0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall8Elts[] = { 2,3, 0, 1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall8]);
    glBindVertexArray(myVAO[iSideWall8]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall8Verts), sidewall8Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall8]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall8Elts), sidewall8Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall9Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -6.0f, 0.8f, -0.25f,       1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 0.0f, -0.25,       1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -6.0f, 0.8f, 0.25f,        1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -6.0f, 0.0f, 0.25f,       1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall9Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall9]);
    glBindVertexArray(myVAO[iSideWall9]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall9Verts), sidewall9Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall9]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall9Elts), sidewall9Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidecover3Verts[] = {
        // Position              // Normal                  // Texture coordinates
        -6.0f, 0.8f, 0.25f,       0.2f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        -6.0f, 0.8f, -0.25f,       0.2f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        -7.5f, 1.0f, 0.25f,        0.2f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        -7.5f, 1.0f, -0.25f,       0.2f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidecover3Elts[] = { 0,1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideCover3]);
    glBindVertexArray(myVAO[iSideCover3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidecover3Verts),sidecover3Verts , GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideCover3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidecover3Elts), sidecover3Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();
    


    float sidewall10Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 1.0f, -4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        4.5f, 0.0f, -4.5f,       0.0f, 0.0f,-1.0f,          0.0f, 0.0f,         // lower left

        6.0f, 1.0f, -4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, -4.5f,       0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall10Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall10]);
    glBindVertexArray(myVAO[iSideWall10]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall10Verts), sidewall10Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall10]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall10Elts), sidewall10Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall11Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 1.0f, -4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        4.5f, 0.0f, -4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        6.0f, 1.0f, -4.0f,        0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, -4.0f,       0.0f, 0.0f,  1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall11Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall11]);
    glBindVertexArray(myVAO[iSideWall11]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall11Verts), sidewall11Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall11]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall11Elts), sidewall11Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float sidewall12Verts[] = {
        // Position              // Normal                  // Texture coordinates
        6.0f, 1.0f, -4.5f,       -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        6.0f, 0.0f, -4.5f,       -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        6.0f, 1.0f, -4.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, -4.0f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall12Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall12]);
    glBindVertexArray(myVAO[iSideWall12]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall12Verts), sidewall12Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall12]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall12Elts), sidewall12Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float isideCover4Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 1.0f, -4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        6.0f, 1.0f, -4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        4.5f, 1.0f, -4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        6.0f, 1.0f, -4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int isideCover4Elts[] = { 3,1,2,0 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideCover4]);
    glBindVertexArray(myVAO[iSideCover4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(isideCover4Verts), isideCover4Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideCover4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(isideCover4Elts), isideCover4Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();





    float sidewall13Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 1.0f, 4.5f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        4.5f, 0.0f, 4.5f,       0.0f, 0.0f,-1.0f,          0.0f, 0.0f,         // lower left

        6.0f, 1.0f, 4.5f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, 4.5f,       0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall13Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall13]);
    glBindVertexArray(myVAO[iSideWall13]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall13Verts), sidewall13Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall13]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall13Elts), sidewall13Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall14Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 1.0f, 4.0f,       0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        4.5f, 0.0f, 4.0f,       0.0f, 0.0f,1.0f,          0.0f, 0.0f,         // lower left

        6.0f, 1.0f, 4.0f,        0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, 4.0f,       0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall14Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall14]);
    glBindVertexArray(myVAO[iSideWall14]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall14Verts), sidewall14Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall14]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall14Elts), sidewall14Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float sidewall15Verts[] = {
        // Position              // Normal                  // Texture coordinates
        6.0f, 1.0f, 4.0f,       -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        6.0f, 0.0f, 4.0f,       -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        6.0f, 1.0f, 4.5f,        -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, 4.5f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall15Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall15]);
    glBindVertexArray(myVAO[iSideWall15]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall15Verts), sidewall15Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall15]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall15Elts), sidewall15Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();


    float isideCover5Verts[] = {
        // Position              // Normal                  // Texture coordinates
        4.5f, 1.0f, 4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        6.0f, 1.0f, 4.5f,       0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        4.5f, 1.0f, 4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        6.0f, 1.0f, 4.0f,       0.0f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int isideCover5Elts[] = { 2,0,3,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideCover5]);
    glBindVertexArray(myVAO[iSideCover5]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(isideCover5Verts), isideCover5Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideCover5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(isideCover5Elts), isideCover5Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall16Verts[] = {
        // Position              // Normal                  // Texture coordinates
        6.0f, 0.8f, -0.25f,       0.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        6.0f, 0.0f, -0.25f,       0.0f, 0.0f,-1.0f,          0.0f, 0.0f,         // lower left

        7.5f, 1.0f, -0.25f,        0.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        7.5f, 0.0f, -0.25f,       0.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall16Elts[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall16]);
    glBindVertexArray(myVAO[iSideWall16]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall16Verts), sidewall16Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall16]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall16Elts), sidewall16Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall17Verts[] = {
        // Position              // Normal                  // Texture coordinates
        6.0f, 0.8f, 0.25f,       0.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        6.0f, 0.0f, 0.25f,       0.0f, 0.0f,1.0f,          0.0f, 0.0f,         // lower left

        7.5f, 1.0f, 0.25f,        0.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        7.5f, 0.0f, 0.25f,       0.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall17Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall17]);
    glBindVertexArray(myVAO[iSideWall17]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall17Verts), sidewall17Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall17]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall17Elts), sidewall17Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidewall18Verts[] = {
        // Position              // Normal                  // Texture coordinates
        6.0f, 0.8f, -0.25f,       -1.0f, 0.0f, 0.0f,          0.0f, 1.0f,         // upper left
        6.0f, 0.0f, -0.25,       -1.0f, 0.0f, 0.0f,          0.0f, 0.0f,         // lower left

        6.0f, 0.8f, 0.25f,        -1.0f, 0.0f, 0.0f,          1.0f, 1.0f,        // upper right
        6.0f, 0.0f, 0.25f,       -1.0f, 0.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidewall18Elts[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideWall18]);
    glBindVertexArray(myVAO[iSideWall18]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidewall18Verts), sidewall18Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideWall18]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidewall18Elts), sidewall18Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float sidecover6Verts[] = {
        // Position              // Normal                  // Texture coordinates
        6.0f, 0.8f, 0.25f,       -0.2f, 1.0f, 0.0f,          0.0f, 1.0f,         // upper left
        6.0f, 0.8f, -0.25f,       -0.2f, 1.0f, 0.0f,          0.0f, 0.0f,         // lower left

        7.5f, 1.0f, 0.25f,        -0.2f, 1.0f, 0.0f,          1.0f, 1.0f,        // upper right
        7.5f, 1.0f, -0.25f,       -0.2f, 1.0f, 0.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int sidecover6Elts[] = { 2,3,0,1};
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iSideCover6]);
    glBindVertexArray(myVAO[iSideCover6]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(sidecover6Verts), sidecover6Verts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iSideCover6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(sidecover6Elts), sidecover6Elts, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float cornerVertex[] = {
        // Position              // Normal                  // Texture coordinates
        -6.5f, 3.0f, -7.5f,       1.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        -6.5f, 0.0f, -7.5f,       1.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        -7.5f, 3.0f, -6.5f,       1.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        -7.5f, 0.0f, -6.5f,       1.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int cornerEle[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCorner1]);
    glBindVertexArray(myVAO[iCorner1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(cornerVertex), cornerVertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCorner1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(cornerEle), cornerEle, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float corner2Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        6.5f, 3.0f, -7.5f,       -1.0f, 0.0f, 1.0f,          0.0f, 1.0f,         // upper left
        6.5f, 0.0f, -7.5f,       -1.0f, 0.0f, 1.0f,          0.0f, 0.0f,         // lower left

        7.5f, 3.0f, -6.5f,       -1.0f, 0.0f, 1.0f,          1.0f, 1.0f,        // upper right
        7.5f, 0.0f, -6.5f,       -1.0f, 0.0f, 1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int corner2Ele[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCorner2]);
    glBindVertexArray(myVAO[iCorner2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(corner2Vertex), corner2Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCorner2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(corner2Ele), corner2Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float corner3Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        -6.5f, 3.0f, 7.5f,       1.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        -6.5f, 0.0f, 7.5f,       1.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        -7.5f, 3.0f, 6.5f,       1.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        -7.5f, 0.0f, 6.5f,       1.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int corner3Ele[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCorner3]);
    glBindVertexArray(myVAO[iCorner3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(corner3Vertex), corner3Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCorner3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(corner3Ele), corner3Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float corner4Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        6.5f, 3.0f, 7.5f,       -1.0f, 0.0f, -1.0f,          0.0f, 1.0f,         // upper left
        6.5f, 0.0f, 7.5f,       -1.0f, 0.0f, -1.0f,          0.0f, 0.0f,         // lower left

        7.5f, 3.0f, 6.5f,       -1.0f, 0.0f, -1.0f,          1.0f, 1.0f,        // upper right
        7.5f, 0.0f, 6.5f,       -1.0f, 0.0f, -1.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int corner4Ele[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCorner4]);
    glBindVertexArray(myVAO[iCorner4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(corner4Vertex), corner4Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCorner4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(corner4Ele), corner4Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float m1Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        -0.5f, 3.0f, -7.5f,       -1.0f, 0.0f, 3.0f,          0.0f, 1.0f,         // upper left
        -0.5f, 0.0f, -7.5f,      -1.0f, 0.0f, 3.0f,          0.0f, 0.0f,         // lower left

        0.0f, 2.5f, -6.0f,       -1.0f, 0.0f, 3.0f,          1.0f, 1.0f,        // upper right
        0.0f, 0.0f, -6.0f,       -1.0f, 0.0f, 3.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int m1Ele[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[im1]);
    glBindVertexArray(myVAO[im1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(m1Vertex), m1Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[im1]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m1Ele), m1Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float m2Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        0.5f, 3.0f, -7.5f,      1.0f, 0.0f, 3.0f,          0.0f, 1.0f,         // upper left
        0.5f, 0.0f, -7.5f,      1.0f, 0.0f, 3.0f,          0.0f, 0.0f,         // lower left

        0.0f, 2.5f, -6.0f,       1.0f, 0.0f, 3.0f,          1.0f, 1.0f,        // upper right
        0.0f, 0.0f, -6.0f,       1.0f, 0.0f, 3.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int m2Ele[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[im2]);
    glBindVertexArray(myVAO[im2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(m2Vertex), m2Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[im2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m2Ele), m2Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float m3Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        0.5f, 3.0f, -7.5f,      0.0f, 1.0f, 3.0f,          0.0f, 1.0f,         // upper left
        -0.5f, 3.0f, -7.5f,      0.0f, 1.0f, 3.0f,          0.0f, 0.0f,         // lower left

        0.0f, 2.5f, -6.0f,       0.0f, 1.0f, 3.0f,          1.0f, 1.0f,        // upper right
    };

    unsigned int m3Ele[] = { 0,1,2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[im3]);
    glBindVertexArray(myVAO[im3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(m3Vertex), m3Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[im3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m3Ele), m3Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float m4Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        -0.5f, 3.0f, 7.5f,       -1.0f, 0.0f, -3.0f,          0.0f, 1.0f,         // upper left
        -0.5f, 0.0f, 7.5f,      -1.0f, 0.0f, -3.0f,          0.0f, 0.0f,         // lower left

        0.0f, 2.5f, 6.0f,       -1.0f, 0.0f, -3.0f,          1.0f, 1.0f,        // upper right
        0.0f, 0.0f, 6.0f,       -1.0f, 0.0f, -3.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int m4Ele[] = { 2,3,0,1 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[im4]);
    glBindVertexArray(myVAO[im4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(m4Vertex), m4Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[im4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m4Ele), m4Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float m5Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        0.5f, 3.0f, 7.5f,      1.0f, 0.0f, -3.0f,          0.0f, 1.0f,         // upper left
        0.5f, 0.0f, 7.5f,      1.0f, 0.0f, -3.0f,          0.0f, 0.0f,         // lower left

        0.0f, 2.5f, 6.0f,       1.0f, 0.0f, -3.0f,          1.0f, 1.0f,        // upper right
        0.0f, 0.0f, 6.0f,       1.0f, 0.0f, -3.0f,          1.0f, 0.0f,        // lower right
    };

    unsigned int m5Ele[] = { 0,1,2,3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[im5]);
    glBindVertexArray(myVAO[im5]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(m5Vertex), m5Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[im5]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m5Ele), m5Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();

    float m6Vertex[] = {
        // Position              // Normal                  // Texture coordinates
        0.5f, 3.0f, 7.5f,      0.0f, 1.0f, -3.0f,          0.0f, 1.0f,         // upper left
        -0.5f, 3.0f, 7.5f,      0.0f, 1.0f, -3.0f,          0.0f, 0.0f,         // lower left

        0.0f, 2.5f, 6.0f,       0.0f, 1.0f, -3.0f,          1.0f, 1.0f,        // upper right
    };

    unsigned int m6Ele[] = { 0,1,2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[im6]);
    glBindVertexArray(myVAO[im6]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(m6Vertex), m6Vertex, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									                   // Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									                                    // Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									                                // Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[im6]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(m6Ele), m6Ele, GL_STATIC_DRAW);
    check_for_opengl_errors();



}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    //SamsRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes );

    check_for_opengl_errors();      // Watch the console window for error messages!
}

// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************

void MyRenderGeometries() {

    float matEntries[16];       // Temporary storage for floats
    // ******
    // Render the Floor - using a procedural texture map
    // ******
    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // **************
    // Render the circular surface
    /*selectShaderProgram(shaderProgramBitmap);
    SamsRenderCircularSurf();*/

    // ************ 
    // Render the back wall
    //  YOU MUST WRITE THIS. IT WILL BE SIMILAR TO THE FLOOR ABOVE. 
    //  BUT USE A BITMAP (shaderProgramBitmap) INSTEAD OF A PROCEDURAL TEXTURE.

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iWall4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[icover]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle5]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle6]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle7]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle8]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try8]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_FAN, 7, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle9]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle10]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle11]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle12]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try12]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_FAN, 7, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle13]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle14]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle15]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();


    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iMiddle16]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try16]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_FAN, 7, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall1]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideCover1]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall5]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall6]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideCover2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall7]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall8]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall9]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideCover3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall10]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall11]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall12]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideCover4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall13]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall14]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall15]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideCover5]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall16]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall17]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideWall18]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iSideCover6]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iCorner1]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iCorner2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iCorner3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[iCorner4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[im1]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[im2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[im3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[im4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[im5]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[im6]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try1]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_FAN, 7, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try5]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try6]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try7]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try9]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try10]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try11]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try13]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try14]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    selectShaderProgram(shaderProgramBitmap);
    glBindVertexArray(myVAO[try15]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[4]);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

}
